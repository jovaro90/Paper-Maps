{
  "version": 3,
  "sources": ["../../isa.js/IsA.js", "../../hashed/lib/util.js", "../../hashed/lib/serializers.js", "../../hashed/lib/deserializers.js", "../../hashed/lib/field.js", "../../hashed/lib/schema.js", "../../hashed/lib/store.js", "../../hashed/lib/hash.js", "../../hashed/lib/main.js", "../../ol-hashed/index.js"],
  "sourcesContent": ["var boolTag = \"[object Boolean]\",\n\tdateTag = \"[object Date]\",\n\terrorTag = \"[object Error]\",\n\tfuncTag = \"[object Function]\",\n\tafuncTag = \"[object AsyncFunction]\",\n\tnumberTag = \"[object Number]\",\n\tobjectTag = \"[object Object]\",\n\tregexpTag = \"[object RegExp]\",\n\tstringTag = \"[object String]\";\n\nvar objectProto = Object.prototype;\n\nvar objToString = objectProto.toString;\nvar fnToString = Function.prototype.toString;\nvar objCtorString = fnToString.call(Object);\n\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/gm;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\nvar NAME_PATTERN = /([\\\\.A-Za-z]+)/g;\n\nlet Services = {\n\tgetPrototypeOf: Object.getPrototypeOf,\n\tisHostObject: function (value) {\n\t\tvar result = false;\n\t\tif (value !== null && typeof value.toString !== \"function\") {\n\t\t\ttry {\n\t\t\t\tresult = !!(value + \"\");\n\t\t\t} catch (e) {}\n\t\t}\n\t\treturn result;\n\t},\n\tisDefined(value) {\n\t\treturn value !== undefined && value !== null;\n\t},\n\tisIterable(obj) {\n\t\tif (!Services.isDefined(obj)) return false;\n\n\t\treturn typeof obj[Symbol.iterator] === \"function\";\n\t},\n\tisPromise(p) {\n\t\treturn p && Object.prototype.toString.call(p) === \"[object Promise]\";\n\t},\n\tisPlainObject: function (value) {\n\t\tif (\n\t\t\t!this.isObjectLike(value) ||\n\t\t\tobjToString.call(value) !== objectTag ||\n\t\t\tthis.isHostObject(value)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tvar proto =\n\t\t\ttypeof value.constructor === \"function\"\n\t\t\t\t? this.getPrototypeOf(value)\n\t\t\t\t: objectProto;\n\n\t\tif (proto === null) {\n\t\t\treturn true;\n\t\t}\n\t\tvar Ctor = proto.constructor;\n\t\treturn (\n\t\t\ttypeof Ctor === \"function\" &&\n\t\t\tCtor instanceof Ctor &&\n\t\t\tfnToString.call(Ctor) === objCtorString\n\t\t);\n\t},\n\tisObjectLike: function (value) {\n\t\treturn !!value && typeof value === \"object\";\n\t},\n\tisArray: Array.isArray,\n\tisObject: function (value) {\n\t\tvar type = typeof value;\n\t\treturn !!value && (type === \"object\" || type === \"function\");\n\t},\n\tisError: function (value) {\n\t\treturn (\n\t\t\tthis.isObjectLike(value) &&\n\t\t\ttypeof value.message === \"string\" &&\n\t\t\tobjToString.call(value) === errorTag\n\t\t);\n\t},\n\tisNumber: function (value) {\n\t\treturn (\n\t\t\ttypeof value === \"number\" ||\n\t\t\t(this.isObjectLike(value) && objToString.call(value) === numberTag)\n\t\t);\n\t},\n\tisDate: function (value) {\n\t\treturn this.isObjectLike(value) && objToString.call(value) === dateTag;\n\t},\n\tisFunction: function (value) {\n\t\treturn (\n\t\t\tthis.isObject(value) &&\n\t\t\t(objToString.call(value) === funcTag ||\n\t\t\t\tobjToString.call(value) === afuncTag)\n\t\t);\n\t},\n\tisSyncFunction: function (value) {\n\t\treturn this.isObject(value) && objToString.call(value) === funcTag;\n\t},\n\tisAsyncFunction: function (value) {\n\t\treturn this.isObject(value) && objToString.call(value) === afuncTag;\n\t},\n\tisBoolean: function (value) {\n\t\treturn (\n\t\t\tvalue === true ||\n\t\t\tvalue === false ||\n\t\t\t(this.isObjectLike(value) && objToString.call(value) === boolTag)\n\t\t);\n\t},\n\tisString: function (value) {\n\t\treturn (\n\t\t\ttypeof value === \"string\" ||\n\t\t\t(this.isObjectLike(value) && objToString.call(value) === stringTag)\n\t\t);\n\t},\n\tisRegExp: function (value) {\n\t\treturn this.isObject(value) && objToString.call(value) === regexpTag;\n\t},\n\tisPrimitive: function (value) {\n\t\treturn (\n\t\t\tServices.isString(value) ||\n\t\t\tServices.isBoolean(value) ||\n\t\t\tServices.isNumber(value) ||\n\t\t\tServices.isDate(value)\n\t\t);\n\t},\n\twalk: function (object, path, defaultValue) {\n\t\tif (!path) return defaultValue;\n\n\t\tlet oPath = Array.isArray(path) ? path : path.split(\".\");\n\n\t\tif (!object && oPath.length === 0) return true;\n\t\tfor (let key of oPath) {\n\t\t\tif (!object || !object[key]) return defaultValue;\n\t\t\tobject = object[key];\n\t\t}\n\t\treturn object || defaultValue;\n\t},\n\tisValidPath: function (object, path) {\n\t\treturn !!Services.walk(object, path, null);\n\t},\n\tparameterNames: function (func) {\n\t\tvar fnStr = func.toString().replace(STRIP_COMMENTS, \"\");\n\t\tvar result = fnStr\n\t\t\t.slice(fnStr.indexOf(\"(\") + 1, fnStr.indexOf(\")\"))\n\t\t\t.match(ARGUMENT_NAMES);\n\t\tif (result === null) result = [];\n\t\tresult = result.map((p) => {\n\t\t\tvar index = p.indexOf(\"=\");\n\t\t\treturn index === -1 ? p : p.substring(0, index);\n\t\t});\n\t\tresult = result.filter((p) => {\n\t\t\treturn p.length > 0 && p.match(NAME_PATTERN);\n\t\t});\n\t\treturn result;\n\t},\n\tpick: function (object, predicate, ignore, target) {\n\t\tif (!object) return {};\n\n\t\tif (!predicate) predicate = Object.keys(object);\n\t\telse if (!Array.isArray(predicate)) predicate = Object.keys(predicate);\n\n\t\tif (!ignore) ignore = [];\n\t\telse if (!Array.isArray(ignore)) ignore = Object.keys(ignore);\n\n\t\tlet res = target || {};\n\t\tfor (let key of predicate)\n\t\t\tif (!ignore.includes(key) && object.hasOwnProperty(key))\n\t\t\t\tres[key] = object[key];\n\t\treturn res;\n\t},\n\tfunctionsOf(obj, asyncOnly = false) {\n\t\tlet res = [];\n\t\tif (!obj) return res;\n\n\t\tfor (let m in obj)\n\t\t\tif (\n\t\t\t\tobj[m] &&\n\t\t\t\t(asyncOnly\n\t\t\t\t\t? this.isAsyncFunction(obj[m])\n\t\t\t\t\t: this.isFunction(obj[m]))\n\t\t\t)\n\t\t\t\tres.push(obj[m]);\n\t\treturn res;\n\t},\n\tfunctionNames(obj, asyncOnly = false) {\n\t\tlet res = [];\n\t\tif (!obj) return res;\n\n\t\tfor (let m in obj)\n\t\t\tif (\n\t\t\t\tobj[m] &&\n\t\t\t\t(asyncOnly\n\t\t\t\t\t? this.isAsyncFunction(obj[m])\n\t\t\t\t\t: this.isFunction(obj[m]))\n\t\t\t)\n\t\t\t\tres.push(m);\n\t\treturn res;\n\t},\n};\n\nmodule.exports = Services;\n", "const isa = require('isa.js');\n\n/**\n * Get the type of a value.\n * @param {*} value The value.\n * @return {string} The type.\n */\nexports.typeOf = function typeOf(value) {\n  let type = typeof value;\n  if (type === 'object') {\n    if (value === null) {\n      type = 'null';\n    } else if (isa.isArray(value)) {\n      type = 'array';\n    } else if (isa.isDate(value)) {\n      type = 'date';\n    } else if (isa.isRegExp(value)) {\n      type = 'regexp';\n    } else if (isa.isError(value)) {\n      type = 'error';\n    }\n  }\n  return type;\n};\n\n/**\n * Copy properties from one object to another.\n * @param {Object} dest The destination object.\n * @param {Object} source The source object.\n * @return {Object} The destination object.\n */\nexports.extend = function(dest, source) {\n  for (const key in source) {\n    dest[key] = source[key];\n  }\n  return dest;\n};\n\n/**\n * Generate an array of alternating name, value from an object's properties.\n * @param {Object} object The object to zip.\n * @return {Array} The array of name, value [, name, value]*.\n */\nexports.zip = function(object) {\n  const zipped = [];\n  let count = 0;\n  for (const key in object) {\n    zipped[2 * count] = key;\n    zipped[2 * count + 1] = object[key];\n    ++count;\n  }\n  return zipped;\n};\n\n/**\n * Generate an object from an array of alternating name, value items.\n * @param {Array} array The array of name, value [, name, value]*.\n * @return {Object} The zipped up object.\n */\nexports.unzip = function(array) {\n  const object = {};\n  for (let i = 0, ii = array.length; i < ii; i += 2) {\n    object[array[i]] = array[i + 1];\n  }\n  return object;\n};\n", "const isa = require('isa.js');\n\nconst enc = encodeURIComponent;\n\nconst serializers = {\n  string: function(str) {\n    if (typeof str !== 'string') {\n      throw new Error('Expected string to serialize: ' + str);\n    }\n    return enc(str);\n  },\n  number: function(num) {\n    if (typeof num !== 'number') {\n      throw new Error('Expected number to serialize: ' + num);\n    }\n    return enc(String(num));\n  },\n  boolean: function(bool) {\n    if (typeof bool !== 'boolean') {\n      throw new Error('Expected boolean to serialize: ' + bool);\n    }\n    return bool ? '1' : '0';\n  },\n  date: function(date) {\n    if (!isa.isDate(date)) {\n      throw new Error('Expected date to serialize: ' + date);\n    }\n    return enc(date.toISOString());\n  },\n  array: function(array) {\n    if (!isa.isArray(array)) {\n      throw new Error('Expected array to serialize: ' + array);\n    }\n    return enc(JSON.stringify(array));\n  },\n  object: function(obj) {\n    return enc(JSON.stringify(obj));\n  }\n};\n\n/**\n * Get a serializer for a value of the given type.\n * @param {string} type Value type.\n * @return {function(*): string} Function that serializes a value to a string.\n */\nexports.get = function(type) {\n  if (!(type in serializers)) {\n    throw new Error('Unable to serialize type: ' + type);\n  }\n  return serializers[type];\n};\n", "const util = require('./util');\n\nconst dec = decodeURIComponent;\n\nconst noop = function() {};\n\nconst deserializers = {\n  string: function(str) {\n    if (!str || typeof str !== 'string') {\n      throw new Error('Expected string to deserialize: ' + str);\n    }\n    return dec(str);\n  },\n  number: function(str) {\n    if (!str || typeof str !== 'string') {\n      throw new Error('Expected string to deserialize: ' + str);\n    }\n    const num = Number(dec(str));\n    if (isNaN(num)) {\n      throw new Error('Expected to deserialize a number: ' + str);\n    }\n    return num;\n  },\n  boolean: function(str) {\n    if (!str || typeof str !== 'string') {\n      throw new Error('Expected string to deserialize: ' + str);\n    }\n    let bool;\n    if (str === '1') {\n      bool = true;\n    } else if (str === '0') {\n      bool = false;\n    } else {\n      throw new Error('Expected \"1\" or \"0\" for boolean: ' + str);\n    }\n    return bool;\n  },\n  date: function(str) {\n    if (!str || typeof str !== 'string') {\n      throw new Error('Expected string to deserialize: ' + str);\n    }\n    const date = new Date(dec(str));\n    if (isNaN(date.getTime())) {\n      throw new Error('Expected to deserialize a date: ' + str);\n    }\n    return date;\n  },\n  array: function(str) {\n    if (!str || typeof str !== 'string') {\n      throw new Error('Expected string to deserialize: ' + str);\n    }\n    let array;\n    try {\n      array = JSON.parse(dec(str));\n    } catch (err) {\n      noop();\n    }\n    if (!array || util.typeOf(array) !== 'array') {\n      throw new Error('Expected to deserialize an array: ' + str);\n    }\n    return array;\n  },\n  object: function(str) {\n    if (!str || typeof str !== 'string') {\n      throw new Error('Expected string to deserialize: ' + str);\n    }\n    let obj;\n    try {\n      obj = JSON.parse(dec(str));\n    } catch (err) {\n      noop();\n    }\n    if (!obj || util.typeOf(obj) !== 'object') {\n      throw new Error('Expected to deserialize an object: ' + str);\n    }\n    return obj;\n  }\n};\n\n/**\n * Get a deserializer for a value of the given type.\n * @param {string} type Value type.\n * @return {function(string): *} Function that deserializes a string to a value.\n */\nexports.get = function(type) {\n  if (!(type in deserializers)) {\n    throw new Error('Unable to deserialize type: ' + type);\n  }\n  return deserializers[type];\n};\n", "const util = require('./util');\n\nconst serializers = require('./serializers');\nconst deserializers = require('./deserializers');\n\n/**\n * Create a new field.  A field must have a default value (`default`) and is\n * capable of serializing and deserializing values.\n * @param {Object} config Field configuration.  Must have a `default` property\n *     with a default value.  May have optional `serialize` and `deserialize`\n *     functions.  As a shorthand for providing a config object with a `default`\n *     property, a default value may be provided directly.\n * @constructor\n */\nexports.Field = function(config) {\n  if (util.typeOf(config) !== 'object') {\n    this.default = config;\n  } else if (!('default' in config)) {\n    throw new Error('Missing default');\n  } else {\n    this.default = config.default;\n  }\n\n  const type = util.typeOf(this.default);\n  this.serialize = config.serialize || serializers.get(type);\n  this.deserialize = config.deserialize || deserializers.get(type);\n};\n", "const Field = require('./field').Field;\nconst util = require('./util');\n\n/**\n * Create a new schema.  A schema is a collection of field definitions.\n * @param {Object} config Keys are field names, values are field configs.\n * @constructor\n */\nconst Schema = (exports.Schema = function(config) {\n  config = util.extend({}, config);\n  const fields = {};\n  let prefix;\n  if ('_' in config) {\n    prefix = config._;\n    delete config._;\n  }\n  for (const key in config) {\n    fields[key] = new Field(config[key]);\n  }\n  this._prefix = prefix;\n  this._fields = fields;\n});\n\n/**\n * Get the prefixed version of a key.\n * @param {string} key The key.\n * @return {string} The prefixed key.\n */\nSchema.prototype.getPrefixed = function(key) {\n  return this._prefix ? this._prefix + '.' + key : key;\n};\n\n/**\n * Call a callback for each field key.\n * @param {function(string, number)} callback Called with a local field key and\n *     a prefixed key.\n * @param {Object} thisArg This argument for the callback.\n */\nSchema.prototype.forEachKey = function(callback, thisArg) {\n  let more;\n  for (const key in this._fields) {\n    more = callback.call(thisArg, key, this.getPrefixed(key));\n    if (more === false) {\n      return;\n    }\n  }\n};\n\n/**\n * Serialize a value.\n * @param {string} key The key or field name.\n * @param {*} value The value to serialize.\n * @param {Object} values Additional values for providers to use when serializing.\n * @return {string} The serialized value.\n */\nSchema.prototype.serialize = function(key, value, values) {\n  if (!(key in this._fields)) {\n    throw new Error('Unknown key: ' + key);\n  }\n  return this._fields[key].serialize(value, values);\n};\n\n/**\n * Deserialize a value.\n * @param {string} key The key or field name.\n * @param {string} str The serialized value.\n * @return {*} The deserialized value.\n */\nSchema.prototype.deserialize = function(key, str) {\n  if (!(key in this._fields)) {\n    throw new Error('Unknown key: ' + key);\n  }\n  return this._fields[key].deserialize(str);\n};\n\n/**\n * Get the default value for a particular field.\n * @param {string} key The key or field name.\n * @return {*} The default value.\n */\nSchema.prototype.getDefault = function(key) {\n  if (!(key in this._fields)) {\n    throw new Error('Unknown key: ' + key);\n  }\n  return this._fields[key].default;\n};\n\n/**\n * Determine if one schema conflicts with another.  Two schemas conflict if\n * any of their prefixed keys are the same.\n * @param {Schema} other The other schema.\n * @return {boolean|string} This schema conflicts with the other.  If the two\n *     schemas conflict, the return will be the first conflicting key (with\n *     any prefix).\n */\nSchema.prototype.conflicts = function(other) {\n  const thisPrefixedKeys = {};\n  for (const key in this._fields) {\n    thisPrefixedKeys[this.getPrefixed(key)] = true;\n  }\n\n  let conflicts = false;\n  other.forEachKey(function(_, prefixed) {\n    if (prefixed in thisPrefixedKeys) {\n      conflicts = prefixed;\n    }\n    return !conflicts;\n  });\n  return conflicts;\n};\n", "const Schema = require('./schema').Schema;\nconst util = require('./util');\nconst serializers = require('./serializers');\n\n/**\n * An object backed store of string values.  Allows registering multiple state\n * providers.\n * @param {Object} values Initial serialized values.\n * @param {function(Object)} callback Called with an object of serialized\n *     values and defaults whenever a provider updates state.\n * @constructor\n */\nconst Store = (exports.Store = function(values, callback) {\n  this._values = values;\n  this._defaults = {};\n  this._providers = [];\n  this._callback = callback;\n  this._callbackTimer = null;\n});\n\nStore.prototype._scheduleCallback = function() {\n  if (this._callbackTimer) {\n    clearTimeout(this._callbackTimer);\n  }\n  this._callbackTimer = setTimeout(this._debouncedCallback.bind(this));\n};\n\nStore.prototype._debouncedCallback = function() {\n  this._callbackTimer = null;\n  this._callback(this._values, this._defaults);\n};\n\nStore.prototype.update = function(values) {\n  if (this._updateTimer) {\n    clearTimeout(this._updateTimer);\n  }\n  this._updateTimer = setTimeout(this._debouncedUpdate.bind(this, values));\n};\n\nStore.prototype._debouncedUpdate = function(newValues) {\n  this._updateTimer = null;\n  const values = this._values;\n  const providers = this._providers.slice(); // callbacks may unregister providers\n  for (let i = providers.length - 1; i >= 0; --i) {\n    const provider = providers[i];\n    const schema = provider.schema;\n    let changed = false;\n    const state = {};\n    schema.forEachKey(function(key, prefixed) {\n      let deserialized;\n      if (!(prefixed in newValues)) {\n        deserialized = schema.getDefault(key);\n        const serializedDefault = schema.serialize(key, deserialized);\n        if (values[prefixed] !== serializedDefault) {\n          changed = true;\n          values[prefixed] = serializedDefault;\n          state[key] = deserialized;\n        }\n      } else if (values[prefixed] !== newValues[prefixed]) {\n        try {\n          deserialized = schema.deserialize(key, newValues[prefixed]);\n          values[prefixed] = newValues[prefixed];\n          state[key] = deserialized;\n          changed = true;\n        } catch (err) {\n          // invalid value, pass\n        }\n      }\n    });\n    if (changed && this._providers.indexOf(provider) >= 0) {\n      provider.callback(state);\n    }\n  }\n};\n\n/**\n * Unregister a provider.  Deletes the provider's values from the underlying\n * store and calls the store's callback.\n * @param {Function} callback The provider's callback.\n */\nStore.prototype.unregister = function(callback) {\n  let removedProvider;\n  this._providers = this._providers.filter(function(provider) {\n    const remove = provider.callback === callback;\n    if (remove) {\n      removedProvider = provider;\n    }\n    return !remove;\n  });\n  if (!removedProvider) {\n    throw new Error('Unable to unregister hashed state provider');\n  }\n  const values = this._values;\n  const defaults = this._defaults;\n  removedProvider.schema.forEachKey(function(key, prefixed) {\n    delete values[prefixed];\n    delete defaults[prefixed];\n  });\n  this._scheduleCallback();\n};\n\n/**\n * Register a new state provider.\n * @param {Object} config Schema config.\n * @param {function(Object)} callback Called by the store on state changes.\n * @return {function(Object)} Called by the provider on state changes.\n */\nStore.prototype.register = function(config, callback) {\n  const provider = {\n    schema: new Schema(config),\n    callback: callback\n  };\n\n  // ensure there are no conflicts with existing providers\n  for (let i = 0, ii = this._providers.length; i < ii; ++i) {\n    const conflicts = provider.schema.conflicts(this._providers[i].schema);\n    if (conflicts) {\n      throw new Error(\n        'Provider already registered using the same name: ' + conflicts\n      );\n    }\n    if (provider.callback === this._providers[i].callback) {\n      throw new Error('Provider already registered with the same callback');\n    }\n  }\n\n  this._providers.push(provider);\n  this._initializeProvider(provider);\n\n  return function update(state) {\n    if (this._providers.indexOf(provider) === -1) {\n      throw new Error('Unregistered provider attempting to update state');\n    }\n    const schema = provider.schema;\n    let changed = false;\n    const values = this._values;\n    schema.forEachKey(function(key, prefixed) {\n      if (key in state) {\n        const serializedValue = schema.serialize(key, state[key], state);\n        if (values[prefixed] !== serializedValue) {\n          changed = true;\n          values[prefixed] = serializedValue;\n        }\n      }\n    });\n    if (changed) {\n      this._scheduleCallback();\n    }\n  }.bind(this);\n};\n\n/**\n * Call provider with initial values.\n * @param {Object} provider Provider to be initialized.\n */\nStore.prototype._initializeProvider = function(provider) {\n  const state = {};\n  const defaults = {};\n  const values = this._values;\n  provider.schema.forEachKey(function(key, prefixed) {\n    let deserializedValue;\n    const deserializedDefault = provider.schema.getDefault(key);\n    const serializedDefault = provider.schema.serialize(\n      key,\n      deserializedDefault\n    );\n    if (prefixed in values) {\n      try {\n        deserializedValue = provider.schema.deserialize(key, values[prefixed]);\n      } catch (err) {\n        deserializedValue = deserializedDefault;\n      }\n    } else {\n      deserializedValue = deserializedDefault;\n    }\n    state[key] = deserializedValue;\n    defaults[prefixed] = serializedDefault;\n    values[prefixed] = provider.schema.serialize(key, deserializedValue);\n  });\n  for (const prefixed in defaults) {\n    this._defaults[prefixed] = defaults[prefixed];\n  }\n  provider.callback(state);\n};\n\n/**\n * Serialize values with provider serializers where available.\n * @param {Object} values Values to be serialized.\n * @return {Object} The serialized values.\n */\nStore.prototype.serialize = function(values) {\n  const serialized = {};\n  for (let i = 0, ii = this._providers.length; i < ii; ++i) {\n    const provider = this._providers[i];\n    provider.schema.forEachKey(function(key, prefixed) {\n      if (prefixed in values) {\n        serialized[prefixed] = provider.schema.serialize(\n          key,\n          values[prefixed],\n          values\n        );\n      }\n    });\n  }\n  for (const key in values) {\n    if (!(key in serialized)) {\n      const value = values[key];\n      const type = util.typeOf(value);\n      const serializer = serializers.get(type);\n      serialized[key] = serializer(value);\n    }\n  }\n  return serialized;\n};\n", "const util = require('./util');\n\n/**\n * Get values from a hash string.\n * @param {string} hash The hash string (e.g. '#/foo/bar').\n * @return {Object} The string values (e.g. {foo: 'bar'}).\n */\nfunction deserialize(hash) {\n  let zipped;\n  if (hash.length > 2) {\n    const path = hash.substring(2);\n    zipped = path.split('/');\n  } else {\n    zipped = [];\n  }\n  return util.unzip(zipped);\n}\n\n/**\n * Serialize values for the hash.\n * @param {Object} values The values to serialize.\n * @return {string} The hash string.\n */\nfunction serialize(values) {\n  let path = '#';\n  const parts = util.zip(values);\n  if (parts.length > 0) {\n    path = '#/' + parts.join('/');\n  }\n  return path;\n}\n\nexports.deserialize = deserialize;\nexports.serialize = serialize;\n", "const Store = require('./store').Store;\nconst hash = require('./hash');\n\nlet store;\n\nfunction reset() {\n  if (store) {\n    window.removeEventListener('popstate', update);\n  }\n  window.addEventListener('popstate', update);\n  store = new Store(hash.deserialize(location.hash), function(\n    values,\n    defaults\n  ) {\n    const nonDefaults = {};\n    for (const key in values) {\n      if (values[key] !== defaults[key]) {\n        nonDefaults[key] = values[key];\n      }\n    }\n    history.pushState(values, '', hash.serialize(nonDefaults));\n  });\n}\n\nfunction update() {\n  store.update(hash.deserialize(location.hash));\n}\n\n/**\n * Register a new state provider.\n * @param {Object} config Schema config.\n * @param {function(Object)} callback Called immediately with initial state.\n * @return {function(Object)} Call this function with any updates to the state.\n */\nexports.register = function(config, callback) {\n  return store.register(config, callback);\n};\n\n/**\n * Unregister an existing state provider.\n * @param {function(Object)} callback Callback registered by the provider.\n */\nexports.unregister = function(callback) {\n  store.unregister(callback);\n};\n\n/**\n * Serialize values as they would be represented in the hash.\n * @param {Object} values An object with values to be serialized.\n * @return {string} The values as they would be represented in the hash.\n */\nexports.serialize = function(values) {\n  return hash.serialize(store.serialize(values));\n};\n\nexports.reset = reset;\n\nreset();\n", "import hashed from 'hashed';\nimport {transform} from 'ol/proj';\n\nfunction toPrecision(value, precision) {\n  const factor = Math.pow(10, precision);\n  return (Math.round(value * factor) / factor).toString();\n}\n\nfunction synchronize(map, options) {\n  options = options || {};\n  let animate;\n  if ('animate' in options) {\n    animate = options.animate;\n  } else {\n    animate = {duration: 250};\n  }\n\n  const view = map.getView();\n  const projection = view.getProjection().getCode();\n\n  let zoom, center, rotation;\n  if (view.isDef()) {\n    zoom = view.getZoom();\n    center = view.getCenter();\n    rotation = view.getRotation();\n  } else {\n    const viewport = map.getViewport();\n    if (viewport) {\n      zoom = Math.LOG2E * Math.log(viewport.clientWidth / 256);\n    } else {\n      zoom = 0;\n    }\n    center = [0, 0];\n    rotation = 0;\n  }\n\n  const config = {\n    center: {\n      default: center,\n      serialize: function(coord, state) {\n        let precision;\n        if (state && 'zoom' in state) {\n          precision = Math.max(0, Math.ceil(Math.log(state.zoom) / Math.LN2));\n        } else {\n          precision = 3;\n        }\n        coord = transform(coord, projection, 'EPSG:4326');\n        return (\n          toPrecision(coord[0], precision) +\n          ',' +\n          toPrecision(coord[1], precision)\n        );\n      },\n      deserialize: function(str) {\n        const parts = str.split(',');\n        if (parts.length !== 2) {\n          throw new Error('Expected lon,lat but got ' + str);\n        }\n        const coord = [parseFloat(parts[0]), parseFloat(parts[1])];\n        return transform(coord, 'EPSG:4326', projection);\n      }\n    },\n    zoom: {\n      default: zoom,\n      serialize: function(value) {\n        return toPrecision(value, 1);\n      },\n      deserialize: Number\n    },\n    rotation: {\n      default: rotation,\n      serialize: function(value) {\n        return toPrecision(value, 2);\n      },\n      deserialize: Number\n    }\n  };\n\n  function hashHandler(state) {\n    if (view.isDef() && animate) {\n      view.animate(Object.assign({}, state, animate));\n      return;\n    }\n    if ('center' in state) {\n      view.setCenter(state.center);\n    }\n    if ('zoom' in state) {\n      view.setZoom(state.zoom);\n    }\n    if ('rotation' in state) {\n      view.setRotation(state.rotation);\n    }\n  }\n\n  const update = hashed.register(config, hashHandler);\n\n  function onMoveEnd() {\n    update({\n      center: view.getCenter(),\n      zoom: view.getZoom(),\n      rotation: view.getRotation()\n    });\n  }\n\n  map.on('moveend', onMoveEnd);\n\n  return function unregister() {\n    map.un('moveend', onMoveEnd);\n    hashed.unregister(hashHandler);\n  };\n}\n\nexport default synchronize;\n"],
  "mappings": "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",
  "names": ["hashed"]
}
