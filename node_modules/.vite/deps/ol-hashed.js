import {
  transform
} from "./chunk-EZ4LBVIF.js";
import "./chunk-HJQ4G45N.js";
import "./chunk-CYGBK25O.js";
import "./chunk-N7WWRR4N.js";
import "./chunk-B42KFBUY.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/isa.js/IsA.js
var require_IsA = __commonJS({
  "node_modules/isa.js/IsA.js"(exports, module) {
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var afuncTag = "[object AsyncFunction]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    var fnToString = Function.prototype.toString;
    var objCtorString = fnToString.call(Object);
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var ARGUMENT_NAMES = /([^\s,]+)/g;
    var NAME_PATTERN = /([\\.A-Za-z]+)/g;
    var Services = {
      getPrototypeOf: Object.getPrototypeOf,
      isHostObject: function(value) {
        var result = false;
        if (value !== null && typeof value.toString !== "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      },
      isDefined(value) {
        return value !== void 0 && value !== null;
      },
      isIterable(obj) {
        if (!Services.isDefined(obj)) return false;
        return typeof obj[Symbol.iterator] === "function";
      },
      isPromise(p) {
        return p && Object.prototype.toString.call(p) === "[object Promise]";
      },
      isPlainObject: function(value) {
        if (!this.isObjectLike(value) || objToString.call(value) !== objectTag || this.isHostObject(value)) {
          return false;
        }
        var proto = typeof value.constructor === "function" ? this.getPrototypeOf(value) : objectProto;
        if (proto === null) {
          return true;
        }
        var Ctor = proto.constructor;
        return typeof Ctor === "function" && Ctor instanceof Ctor && fnToString.call(Ctor) === objCtorString;
      },
      isObjectLike: function(value) {
        return !!value && typeof value === "object";
      },
      isArray: Array.isArray,
      isObject: function(value) {
        var type = typeof value;
        return !!value && (type === "object" || type === "function");
      },
      isError: function(value) {
        return this.isObjectLike(value) && typeof value.message === "string" && objToString.call(value) === errorTag;
      },
      isNumber: function(value) {
        return typeof value === "number" || this.isObjectLike(value) && objToString.call(value) === numberTag;
      },
      isDate: function(value) {
        return this.isObjectLike(value) && objToString.call(value) === dateTag;
      },
      isFunction: function(value) {
        return this.isObject(value) && (objToString.call(value) === funcTag || objToString.call(value) === afuncTag);
      },
      isSyncFunction: function(value) {
        return this.isObject(value) && objToString.call(value) === funcTag;
      },
      isAsyncFunction: function(value) {
        return this.isObject(value) && objToString.call(value) === afuncTag;
      },
      isBoolean: function(value) {
        return value === true || value === false || this.isObjectLike(value) && objToString.call(value) === boolTag;
      },
      isString: function(value) {
        return typeof value === "string" || this.isObjectLike(value) && objToString.call(value) === stringTag;
      },
      isRegExp: function(value) {
        return this.isObject(value) && objToString.call(value) === regexpTag;
      },
      isPrimitive: function(value) {
        return Services.isString(value) || Services.isBoolean(value) || Services.isNumber(value) || Services.isDate(value);
      },
      walk: function(object, path, defaultValue) {
        if (!path) return defaultValue;
        let oPath = Array.isArray(path) ? path : path.split(".");
        if (!object && oPath.length === 0) return true;
        for (let key of oPath) {
          if (!object || !object[key]) return defaultValue;
          object = object[key];
        }
        return object || defaultValue;
      },
      isValidPath: function(object, path) {
        return !!Services.walk(object, path, null);
      },
      parameterNames: function(func) {
        var fnStr = func.toString().replace(STRIP_COMMENTS, "");
        var result = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(ARGUMENT_NAMES);
        if (result === null) result = [];
        result = result.map((p) => {
          var index = p.indexOf("=");
          return index === -1 ? p : p.substring(0, index);
        });
        result = result.filter((p) => {
          return p.length > 0 && p.match(NAME_PATTERN);
        });
        return result;
      },
      pick: function(object, predicate, ignore, target) {
        if (!object) return {};
        if (!predicate) predicate = Object.keys(object);
        else if (!Array.isArray(predicate)) predicate = Object.keys(predicate);
        if (!ignore) ignore = [];
        else if (!Array.isArray(ignore)) ignore = Object.keys(ignore);
        let res = target || {};
        for (let key of predicate)
          if (!ignore.includes(key) && object.hasOwnProperty(key))
            res[key] = object[key];
        return res;
      },
      functionsOf(obj, asyncOnly = false) {
        let res = [];
        if (!obj) return res;
        for (let m in obj)
          if (obj[m] && (asyncOnly ? this.isAsyncFunction(obj[m]) : this.isFunction(obj[m])))
            res.push(obj[m]);
        return res;
      },
      functionNames(obj, asyncOnly = false) {
        let res = [];
        if (!obj) return res;
        for (let m in obj)
          if (obj[m] && (asyncOnly ? this.isAsyncFunction(obj[m]) : this.isFunction(obj[m])))
            res.push(m);
        return res;
      }
    };
    module.exports = Services;
  }
});

// node_modules/hashed/lib/util.js
var require_util = __commonJS({
  "node_modules/hashed/lib/util.js"(exports) {
    var isa = require_IsA();
    exports.typeOf = function typeOf(value) {
      let type = typeof value;
      if (type === "object") {
        if (value === null) {
          type = "null";
        } else if (isa.isArray(value)) {
          type = "array";
        } else if (isa.isDate(value)) {
          type = "date";
        } else if (isa.isRegExp(value)) {
          type = "regexp";
        } else if (isa.isError(value)) {
          type = "error";
        }
      }
      return type;
    };
    exports.extend = function(dest, source) {
      for (const key in source) {
        dest[key] = source[key];
      }
      return dest;
    };
    exports.zip = function(object) {
      const zipped = [];
      let count = 0;
      for (const key in object) {
        zipped[2 * count] = key;
        zipped[2 * count + 1] = object[key];
        ++count;
      }
      return zipped;
    };
    exports.unzip = function(array) {
      const object = {};
      for (let i = 0, ii = array.length; i < ii; i += 2) {
        object[array[i]] = array[i + 1];
      }
      return object;
    };
  }
});

// node_modules/hashed/lib/serializers.js
var require_serializers = __commonJS({
  "node_modules/hashed/lib/serializers.js"(exports) {
    var isa = require_IsA();
    var enc = encodeURIComponent;
    var serializers = {
      string: function(str) {
        if (typeof str !== "string") {
          throw new Error("Expected string to serialize: " + str);
        }
        return enc(str);
      },
      number: function(num) {
        if (typeof num !== "number") {
          throw new Error("Expected number to serialize: " + num);
        }
        return enc(String(num));
      },
      boolean: function(bool) {
        if (typeof bool !== "boolean") {
          throw new Error("Expected boolean to serialize: " + bool);
        }
        return bool ? "1" : "0";
      },
      date: function(date) {
        if (!isa.isDate(date)) {
          throw new Error("Expected date to serialize: " + date);
        }
        return enc(date.toISOString());
      },
      array: function(array) {
        if (!isa.isArray(array)) {
          throw new Error("Expected array to serialize: " + array);
        }
        return enc(JSON.stringify(array));
      },
      object: function(obj) {
        return enc(JSON.stringify(obj));
      }
    };
    exports.get = function(type) {
      if (!(type in serializers)) {
        throw new Error("Unable to serialize type: " + type);
      }
      return serializers[type];
    };
  }
});

// node_modules/hashed/lib/deserializers.js
var require_deserializers = __commonJS({
  "node_modules/hashed/lib/deserializers.js"(exports) {
    var util = require_util();
    var dec = decodeURIComponent;
    var noop = function() {
    };
    var deserializers = {
      string: function(str) {
        if (!str || typeof str !== "string") {
          throw new Error("Expected string to deserialize: " + str);
        }
        return dec(str);
      },
      number: function(str) {
        if (!str || typeof str !== "string") {
          throw new Error("Expected string to deserialize: " + str);
        }
        const num = Number(dec(str));
        if (isNaN(num)) {
          throw new Error("Expected to deserialize a number: " + str);
        }
        return num;
      },
      boolean: function(str) {
        if (!str || typeof str !== "string") {
          throw new Error("Expected string to deserialize: " + str);
        }
        let bool;
        if (str === "1") {
          bool = true;
        } else if (str === "0") {
          bool = false;
        } else {
          throw new Error('Expected "1" or "0" for boolean: ' + str);
        }
        return bool;
      },
      date: function(str) {
        if (!str || typeof str !== "string") {
          throw new Error("Expected string to deserialize: " + str);
        }
        const date = new Date(dec(str));
        if (isNaN(date.getTime())) {
          throw new Error("Expected to deserialize a date: " + str);
        }
        return date;
      },
      array: function(str) {
        if (!str || typeof str !== "string") {
          throw new Error("Expected string to deserialize: " + str);
        }
        let array;
        try {
          array = JSON.parse(dec(str));
        } catch (err) {
          noop();
        }
        if (!array || util.typeOf(array) !== "array") {
          throw new Error("Expected to deserialize an array: " + str);
        }
        return array;
      },
      object: function(str) {
        if (!str || typeof str !== "string") {
          throw new Error("Expected string to deserialize: " + str);
        }
        let obj;
        try {
          obj = JSON.parse(dec(str));
        } catch (err) {
          noop();
        }
        if (!obj || util.typeOf(obj) !== "object") {
          throw new Error("Expected to deserialize an object: " + str);
        }
        return obj;
      }
    };
    exports.get = function(type) {
      if (!(type in deserializers)) {
        throw new Error("Unable to deserialize type: " + type);
      }
      return deserializers[type];
    };
  }
});

// node_modules/hashed/lib/field.js
var require_field = __commonJS({
  "node_modules/hashed/lib/field.js"(exports) {
    var util = require_util();
    var serializers = require_serializers();
    var deserializers = require_deserializers();
    exports.Field = function(config) {
      if (util.typeOf(config) !== "object") {
        this.default = config;
      } else if (!("default" in config)) {
        throw new Error("Missing default");
      } else {
        this.default = config.default;
      }
      const type = util.typeOf(this.default);
      this.serialize = config.serialize || serializers.get(type);
      this.deserialize = config.deserialize || deserializers.get(type);
    };
  }
});

// node_modules/hashed/lib/schema.js
var require_schema = __commonJS({
  "node_modules/hashed/lib/schema.js"(exports) {
    var Field = require_field().Field;
    var util = require_util();
    var Schema = exports.Schema = function(config) {
      config = util.extend({}, config);
      const fields = {};
      let prefix;
      if ("_" in config) {
        prefix = config._;
        delete config._;
      }
      for (const key in config) {
        fields[key] = new Field(config[key]);
      }
      this._prefix = prefix;
      this._fields = fields;
    };
    Schema.prototype.getPrefixed = function(key) {
      return this._prefix ? this._prefix + "." + key : key;
    };
    Schema.prototype.forEachKey = function(callback, thisArg) {
      let more;
      for (const key in this._fields) {
        more = callback.call(thisArg, key, this.getPrefixed(key));
        if (more === false) {
          return;
        }
      }
    };
    Schema.prototype.serialize = function(key, value, values) {
      if (!(key in this._fields)) {
        throw new Error("Unknown key: " + key);
      }
      return this._fields[key].serialize(value, values);
    };
    Schema.prototype.deserialize = function(key, str) {
      if (!(key in this._fields)) {
        throw new Error("Unknown key: " + key);
      }
      return this._fields[key].deserialize(str);
    };
    Schema.prototype.getDefault = function(key) {
      if (!(key in this._fields)) {
        throw new Error("Unknown key: " + key);
      }
      return this._fields[key].default;
    };
    Schema.prototype.conflicts = function(other) {
      const thisPrefixedKeys = {};
      for (const key in this._fields) {
        thisPrefixedKeys[this.getPrefixed(key)] = true;
      }
      let conflicts = false;
      other.forEachKey(function(_, prefixed) {
        if (prefixed in thisPrefixedKeys) {
          conflicts = prefixed;
        }
        return !conflicts;
      });
      return conflicts;
    };
  }
});

// node_modules/hashed/lib/store.js
var require_store = __commonJS({
  "node_modules/hashed/lib/store.js"(exports) {
    var Schema = require_schema().Schema;
    var util = require_util();
    var serializers = require_serializers();
    var Store = exports.Store = function(values, callback) {
      this._values = values;
      this._defaults = {};
      this._providers = [];
      this._callback = callback;
      this._callbackTimer = null;
    };
    Store.prototype._scheduleCallback = function() {
      if (this._callbackTimer) {
        clearTimeout(this._callbackTimer);
      }
      this._callbackTimer = setTimeout(this._debouncedCallback.bind(this));
    };
    Store.prototype._debouncedCallback = function() {
      this._callbackTimer = null;
      this._callback(this._values, this._defaults);
    };
    Store.prototype.update = function(values) {
      if (this._updateTimer) {
        clearTimeout(this._updateTimer);
      }
      this._updateTimer = setTimeout(this._debouncedUpdate.bind(this, values));
    };
    Store.prototype._debouncedUpdate = function(newValues) {
      this._updateTimer = null;
      const values = this._values;
      const providers = this._providers.slice();
      for (let i = providers.length - 1; i >= 0; --i) {
        const provider = providers[i];
        const schema = provider.schema;
        let changed = false;
        const state = {};
        schema.forEachKey(function(key, prefixed) {
          let deserialized;
          if (!(prefixed in newValues)) {
            deserialized = schema.getDefault(key);
            const serializedDefault = schema.serialize(key, deserialized);
            if (values[prefixed] !== serializedDefault) {
              changed = true;
              values[prefixed] = serializedDefault;
              state[key] = deserialized;
            }
          } else if (values[prefixed] !== newValues[prefixed]) {
            try {
              deserialized = schema.deserialize(key, newValues[prefixed]);
              values[prefixed] = newValues[prefixed];
              state[key] = deserialized;
              changed = true;
            } catch (err) {
            }
          }
        });
        if (changed && this._providers.indexOf(provider) >= 0) {
          provider.callback(state);
        }
      }
    };
    Store.prototype.unregister = function(callback) {
      let removedProvider;
      this._providers = this._providers.filter(function(provider) {
        const remove = provider.callback === callback;
        if (remove) {
          removedProvider = provider;
        }
        return !remove;
      });
      if (!removedProvider) {
        throw new Error("Unable to unregister hashed state provider");
      }
      const values = this._values;
      const defaults = this._defaults;
      removedProvider.schema.forEachKey(function(key, prefixed) {
        delete values[prefixed];
        delete defaults[prefixed];
      });
      this._scheduleCallback();
    };
    Store.prototype.register = function(config, callback) {
      const provider = {
        schema: new Schema(config),
        callback
      };
      for (let i = 0, ii = this._providers.length; i < ii; ++i) {
        const conflicts = provider.schema.conflicts(this._providers[i].schema);
        if (conflicts) {
          throw new Error(
            "Provider already registered using the same name: " + conflicts
          );
        }
        if (provider.callback === this._providers[i].callback) {
          throw new Error("Provider already registered with the same callback");
        }
      }
      this._providers.push(provider);
      this._initializeProvider(provider);
      return (function update(state) {
        if (this._providers.indexOf(provider) === -1) {
          throw new Error("Unregistered provider attempting to update state");
        }
        const schema = provider.schema;
        let changed = false;
        const values = this._values;
        schema.forEachKey(function(key, prefixed) {
          if (key in state) {
            const serializedValue = schema.serialize(key, state[key], state);
            if (values[prefixed] !== serializedValue) {
              changed = true;
              values[prefixed] = serializedValue;
            }
          }
        });
        if (changed) {
          this._scheduleCallback();
        }
      }).bind(this);
    };
    Store.prototype._initializeProvider = function(provider) {
      const state = {};
      const defaults = {};
      const values = this._values;
      provider.schema.forEachKey(function(key, prefixed) {
        let deserializedValue;
        const deserializedDefault = provider.schema.getDefault(key);
        const serializedDefault = provider.schema.serialize(
          key,
          deserializedDefault
        );
        if (prefixed in values) {
          try {
            deserializedValue = provider.schema.deserialize(key, values[prefixed]);
          } catch (err) {
            deserializedValue = deserializedDefault;
          }
        } else {
          deserializedValue = deserializedDefault;
        }
        state[key] = deserializedValue;
        defaults[prefixed] = serializedDefault;
        values[prefixed] = provider.schema.serialize(key, deserializedValue);
      });
      for (const prefixed in defaults) {
        this._defaults[prefixed] = defaults[prefixed];
      }
      provider.callback(state);
    };
    Store.prototype.serialize = function(values) {
      const serialized = {};
      for (let i = 0, ii = this._providers.length; i < ii; ++i) {
        const provider = this._providers[i];
        provider.schema.forEachKey(function(key, prefixed) {
          if (prefixed in values) {
            serialized[prefixed] = provider.schema.serialize(
              key,
              values[prefixed],
              values
            );
          }
        });
      }
      for (const key in values) {
        if (!(key in serialized)) {
          const value = values[key];
          const type = util.typeOf(value);
          const serializer = serializers.get(type);
          serialized[key] = serializer(value);
        }
      }
      return serialized;
    };
  }
});

// node_modules/hashed/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hashed/lib/hash.js"(exports) {
    var util = require_util();
    function deserialize(hash) {
      let zipped;
      if (hash.length > 2) {
        const path = hash.substring(2);
        zipped = path.split("/");
      } else {
        zipped = [];
      }
      return util.unzip(zipped);
    }
    function serialize(values) {
      let path = "#";
      const parts = util.zip(values);
      if (parts.length > 0) {
        path = "#/" + parts.join("/");
      }
      return path;
    }
    exports.deserialize = deserialize;
    exports.serialize = serialize;
  }
});

// node_modules/hashed/lib/main.js
var require_main = __commonJS({
  "node_modules/hashed/lib/main.js"(exports) {
    var Store = require_store().Store;
    var hash = require_hash();
    var store;
    function reset() {
      if (store) {
        window.removeEventListener("popstate", update);
      }
      window.addEventListener("popstate", update);
      store = new Store(hash.deserialize(location.hash), function(values, defaults) {
        const nonDefaults = {};
        for (const key in values) {
          if (values[key] !== defaults[key]) {
            nonDefaults[key] = values[key];
          }
        }
        history.pushState(values, "", hash.serialize(nonDefaults));
      });
    }
    function update() {
      store.update(hash.deserialize(location.hash));
    }
    exports.register = function(config, callback) {
      return store.register(config, callback);
    };
    exports.unregister = function(callback) {
      store.unregister(callback);
    };
    exports.serialize = function(values) {
      return hash.serialize(store.serialize(values));
    };
    exports.reset = reset;
    reset();
  }
});

// node_modules/ol-hashed/index.js
var import_hashed = __toESM(require_main());
function toPrecision(value, precision) {
  const factor = Math.pow(10, precision);
  return (Math.round(value * factor) / factor).toString();
}
function synchronize(map, options) {
  options = options || {};
  let animate;
  if ("animate" in options) {
    animate = options.animate;
  } else {
    animate = { duration: 250 };
  }
  const view = map.getView();
  const projection = view.getProjection().getCode();
  let zoom, center, rotation;
  if (view.isDef()) {
    zoom = view.getZoom();
    center = view.getCenter();
    rotation = view.getRotation();
  } else {
    const viewport = map.getViewport();
    if (viewport) {
      zoom = Math.LOG2E * Math.log(viewport.clientWidth / 256);
    } else {
      zoom = 0;
    }
    center = [0, 0];
    rotation = 0;
  }
  const config = {
    center: {
      default: center,
      serialize: function(coord, state) {
        let precision;
        if (state && "zoom" in state) {
          precision = Math.max(0, Math.ceil(Math.log(state.zoom) / Math.LN2));
        } else {
          precision = 3;
        }
        coord = transform(coord, projection, "EPSG:4326");
        return toPrecision(coord[0], precision) + "," + toPrecision(coord[1], precision);
      },
      deserialize: function(str) {
        const parts = str.split(",");
        if (parts.length !== 2) {
          throw new Error("Expected lon,lat but got " + str);
        }
        const coord = [parseFloat(parts[0]), parseFloat(parts[1])];
        return transform(coord, "EPSG:4326", projection);
      }
    },
    zoom: {
      default: zoom,
      serialize: function(value) {
        return toPrecision(value, 1);
      },
      deserialize: Number
    },
    rotation: {
      default: rotation,
      serialize: function(value) {
        return toPrecision(value, 2);
      },
      deserialize: Number
    }
  };
  function hashHandler(state) {
    if (view.isDef() && animate) {
      view.animate(Object.assign({}, state, animate));
      return;
    }
    if ("center" in state) {
      view.setCenter(state.center);
    }
    if ("zoom" in state) {
      view.setZoom(state.zoom);
    }
    if ("rotation" in state) {
      view.setRotation(state.rotation);
    }
  }
  const update = import_hashed.default.register(config, hashHandler);
  function onMoveEnd() {
    update({
      center: view.getCenter(),
      zoom: view.getZoom(),
      rotation: view.getRotation()
    });
  }
  map.on("moveend", onMoveEnd);
  return function unregister() {
    map.un("moveend", onMoveEnd);
    import_hashed.default.unregister(hashHandler);
  };
}
var ol_hashed_default = synchronize;
export {
  ol_hashed_default as default
};
//# sourceMappingURL=ol-hashed.js.map
