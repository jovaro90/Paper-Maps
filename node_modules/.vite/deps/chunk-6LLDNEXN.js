import {
  assert,
  init_asserts
} from "./chunk-5CC5B27J.js";
import {
  Object_default,
  init_Object
} from "./chunk-3NLNC64D.js";
import {
  Event_default,
  abstract,
  init_Event,
  init_util
} from "./chunk-HLKRVSHM.js";
import {
  clamp,
  init_math
} from "./chunk-OWRDQENW.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default;
var init_CollectionEventType = __esm({
  "node_modules/ol/CollectionEventType.js"() {
    CollectionEventType_default = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: "add",
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: "remove"
    };
  }
});

// node_modules/ol/Collection.js
var Property, CollectionEvent, Collection, Collection_default;
var init_Collection = __esm({
  "node_modules/ol/Collection.js"() {
    init_CollectionEventType();
    init_Object();
    init_Event();
    Property = {
      LENGTH: "length"
    };
    CollectionEvent = class extends Event_default {
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {T} element Element.
       * @param {number} index The index of the added or removed element.
       */
      constructor(type, element, index) {
        super(type);
        this.element = element;
        this.index = index;
      }
    };
    Collection = class extends Object_default {
      /**
       * @param {Array<T>} [array] Array.
       * @param {Options} [options] Collection options.
       */
      constructor(array, options) {
        super();
        this.on;
        this.once;
        this.un;
        options = options || {};
        this.unique_ = !!options.unique;
        this.array_ = array ? array : [];
        if (this.unique_) {
          for (let i = 0, ii = this.array_.length; i < ii; ++i) {
            this.assertUnique_(this.array_[i], i);
          }
        }
        this.updateLength_();
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      extend(arr) {
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          this.push(arr[i]);
        }
        return this;
      }
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      forEach(f) {
        const array = this.array_;
        for (let i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      }
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      getArray() {
        return this.array_;
      }
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      item(index) {
        return this.array_[index];
      }
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      getLength() {
        return this.get(Property.LENGTH);
      }
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      pop() {
        return this.removeAt(this.getLength() - 1);
      }
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      }
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      remove(elem) {
        const arr = this.array_;
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this.removeAt(i);
          }
        }
        return void 0;
      }
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
          return void 0;
        }
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        return prev;
      }
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
          this.insertAt(index, elem);
          return;
        }
        if (index < 0) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem, index);
        }
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * @private
       */
      updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
      }
      /**
       * @private
       * @param {T} elem Element.
       * @param {number} [except] Optional index to ignore.
       */
      assertUnique_(elem, except) {
        for (let i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this.array_[i] === elem && i !== except) {
            throw new Error("Duplicate item added to a unique collection");
          }
        }
      }
    };
    Collection_default = Collection;
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_asserts();
    init_math();
    init_util();
    init_Property();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       * @override
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

export {
  CollectionEventType_default,
  init_CollectionEventType,
  Collection_default,
  init_Collection,
  Property_default,
  init_Property,
  Base_default,
  init_Base
};
//# sourceMappingURL=chunk-6LLDNEXN.js.map
